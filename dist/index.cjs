"use strict";var y=Object.defineProperty;var z=Object.getOwnPropertyDescriptor;var M=Object.getOwnPropertyNames;var j=Object.prototype.hasOwnProperty;var S=(e,t)=>{for(var n in t)y(e,n,{get:t[n],enumerable:!0})},N=(e,t,n,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of M(t))!j.call(e,o)&&o!==n&&y(e,o,{get:()=>t[o],enumerable:!(s=z(t,o))||s.enumerable});return e};var v=e=>N(y({},"__esModule",{value:!0}),e);var Z={};S(Z,{createOpenAI:()=>C,createTool:()=>b,default:()=>K,detectEnvironment:()=>h,generateObject:()=>A,generateText:()=>x,hello:()=>O});module.exports=v(Z);var g=require("zod-to-json-schema");function b(e){let t=async n=>Promise.resolve(e.execute(n));return{name:e.name,description:e.description,parameters:e.parameters,execute:t}}function C(e){let t=(e.baseURL??"https://api-inference.modelscope.cn/v1").replace(/\/$/,""),n=e.apiKey;if(!n)throw new Error("apiKey is required");let s=o=>({provider:"openai",endpoint:`${t}/chat/completions`,model:o,apiKey:n});return s.baseURL=t,s.apiKey=n,s.chat=o=>s(o),s}async function x(e){let{messages:t,onToolCall:n}=e,s=[...t],o=new Map,m=e.tools;if(Array.isArray(m))for(let a of m)o.set(a.name,a);else if(m&&typeof m=="object")for(let[a,c]of Object.entries(m))o.set(a,c);let f=o.size?Array.from(o.values()).map(a=>({type:"function",function:{name:a.name,description:a.description,parameters:(0,g.zodToJsonSchema)(a.parameters)}})):void 0,d=`${("client"in e?e.client.baseURL:e.model.endpoint.replace(/\/chat\/completions$/,"")).replace(/\/$/,"")}/chat/completions`,T="client"in e?e.client.apiKey:e.model.apiKey,p="client"in e?e.model:e.model.model;for(;;){let c=(await fetch(d,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${T}`},body:JSON.stringify({model:p,messages:s,tools:f})}).then(i=>i.json())).choices?.[0]?.message;if(!c)throw new Error("No message returned");s.push(c);let r=c.tool_calls;if(!r||r.length===0)return{text:c.content};n&&r.map(l=>l.function.name).forEach(l=>n(l));for(let i of r){let l=o.get(i.function.name);if(!l)throw new Error(`Tool ${i.function.name} not found`);let R=l.parameters.parse(JSON.parse(i.function.arguments)),w=await l.execute(R);s.push({role:"tool",content:w,tool_call_id:i.id})}}}async function A(e){let t=e.schema,s=`${("client"in e?e.client.baseURL:e.model.endpoint.replace(/\/(?:chat\/completions)?$/,"")).replace(/\/$/,"")}/chat/completions`,o="client"in e?e.client.apiKey:e.model.apiKey,m="client"in e?e.model:e.model.model,u=[{role:"system",content:e.system??"You are a structured-output assistant. Always respond by calling the tool `submit_object` exactly once with the final JSON object. Do not include any other text."},{role:"user",content:e.prompt}],d=[{type:"function",function:{name:"submit_object",description:"Submit the final structured object that matches the required schema.",parameters:(0,g.zodToJsonSchema)(t)}}],p=(await fetch(s,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${o}`},body:JSON.stringify({model:m,messages:u,tools:d})}).then(r=>r.json())).choices?.[0]?.message;if(!p)throw new Error("No message returned");let c=(p.tool_calls??[]).find(r=>r.function?.name==="submit_object");if(c){let r=c.function.arguments||"{}",i=JSON.parse(r);return{object:t.parse(i)}}if(p.content)try{let r=JSON.parse(p.content);return{object:t.parse(r)}}catch{}throw new Error("Model did not return a structured object. Ensure the model supports tool calling.")}function h(){return typeof window<"u"&&typeof document<"u"?"browser":"node"}function O(e="world"){return`Hello, ${e}! from ${h()}`}var K={detectEnvironment:h,hello:O};0&&(module.exports={createOpenAI,createTool,detectEnvironment,generateObject,generateText,hello});
//# sourceMappingURL=index.cjs.map