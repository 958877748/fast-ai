import{zodToJsonSchema as f}from"zod-to-json-schema";function C(e){let s=async i=>Promise.resolve(e.execute(i));return{name:e.name,description:e.description,parameters:e.parameters,execute:s}}function x(e){let s=(e.baseURL??"https://api-inference.modelscope.cn/v1").replace(/\/$/,""),i=e.apiKey;if(!i)throw new Error("apiKey is required");let o=n=>({provider:"openai",endpoint:`${s}/chat/completions`,model:n,apiKey:i});return o.baseURL=s,o.apiKey=i,o.chat=n=>o(n),o}async function A(e){let{messages:s,onToolCall:i}=e,o=[...s],n=new Map,m=e.tools;if(Array.isArray(m))for(let r of m)n.set(r.name,r);else if(m&&typeof m=="object")for(let[r,c]of Object.entries(m))n.set(r,c);let y=n.size?Array.from(n.values()).map(r=>({type:"function",function:{name:r.name,description:r.description,parameters:f(r.parameters)}})):void 0,d=`${("client"in e?e.client.baseURL:e.model.endpoint.replace(/\/chat\/completions$/,"")).replace(/\/$/,"")}/chat/completions`,h="client"in e?e.client.apiKey:e.model.apiKey,p="client"in e?e.model:e.model.model;for(;;){let c=(await fetch(d,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${h}`},body:JSON.stringify({model:p,messages:o,tools:y})}).then(a=>a.json())).choices?.[0]?.message;if(!c)throw new Error("No message returned");o.push(c);let t=c.tool_calls;if(!t||t.length===0)return{text:c.content};i&&t.map(l=>l.function.name).forEach(l=>i(l));for(let a of t){let l=n.get(a.function.name);if(!l)throw new Error(`Tool ${a.function.name} not found`);let T=l.parameters.parse(JSON.parse(a.function.arguments)),b=await l.execute(T);o.push({role:"tool",content:b,tool_call_id:a.id})}}}async function O(e){let s=e.schema,o=`${("client"in e?e.client.baseURL:e.model.endpoint.replace(/\/(?:chat\/completions)?$/,"")).replace(/\/$/,"")}/chat/completions`,n="client"in e?e.client.apiKey:e.model.apiKey,m="client"in e?e.model:e.model.model,g=[{role:"system",content:e.system??"You are a structured-output assistant. Always respond by calling the tool `submit_object` exactly once with the final JSON object. Do not include any other text."},{role:"user",content:e.prompt}],d=[{type:"function",function:{name:"submit_object",description:"Submit the final structured object that matches the required schema.",parameters:f(s)}}],p=(await fetch(o,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${n}`},body:JSON.stringify({model:m,messages:g,tools:d})}).then(t=>t.json())).choices?.[0]?.message;if(!p)throw new Error("No message returned");let c=(p.tool_calls??[]).find(t=>t.function?.name==="submit_object");if(c){let t=c.function.arguments||"{}",a=JSON.parse(t);return{object:s.parse(a)}}if(p.content)try{let t=JSON.parse(p.content);return{object:s.parse(t)}}catch{}throw new Error("Model did not return a structured object. Ensure the model supports tool calling.")}function u(){return typeof window<"u"&&typeof document<"u"?"browser":"node"}function R(e="world"){return`Hello, ${e}! from ${u()}`}var M={detectEnvironment:u,hello:R};export{x as createOpenAI,C as createTool,M as default,u as detectEnvironment,O as generateObject,A as generateText,R as hello};
//# sourceMappingURL=index.js.map