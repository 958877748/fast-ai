{"version":3,"sources":["../src/index.ts","../src/fastai.ts"],"sourcesContent":["export type Environment = 'node' | 'browser';\n\nexport function detectEnvironment(): Environment {\n  const isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n  return isBrowser ? 'browser' : 'node';\n}\n\nexport function hello(name: string = 'world'): string {\n  return `Hello, ${name}! from ${detectEnvironment()}`;\n}\n\nexport default {\n  detectEnvironment,\n  hello,\n};\n\nexport {\n  createOpenAI,\n  generateText,\n  createTool,\n} from './fastai';\n\nexport type {\n  ChatMessage,\n  Tool,\n} from './fastai';\n","import { z } from 'zod';\nimport { zodToJsonSchema } from 'zod-to-json-schema';\n\nexport type ChatMessage = {\n    role: 'user' | 'assistant' | 'system' | 'tool';\n    content: string;\n    tool_calls?: Array<ToolCall>\n    tool_call_id?: string\n};\n\nexport type Tool<T extends z.ZodTypeAny> = {\n    name: string;\n    description?: string;\n    parameters: T;\n    execute: (args: z.infer<T>) => Promise<string>;\n};\n\n// Helper to create a typed tool with Zod parameters\nexport function createTool<T extends z.ZodTypeAny>(options: {\n    name: string;\n    description?: string;\n    parameters: T;\n    execute: (args: z.infer<T>) => Promise<string> | string;\n}): Tool<T> {\n    const wrappedExecute = async (args: z.infer<T>): Promise<string> => {\n        return Promise.resolve(options.execute(args));\n    };\n    return {\n        name: options.name,\n        description: options.description,\n        parameters: options.parameters,\n        execute: wrappedExecute,\n    };\n}\n\ntype ToolCall = {\n    index: number\n    id: string\n    type: string\n    function: {\n        name: string\n        arguments: string\n    }\n}\n\ntype ChatRespose = {\n    choices: Array<{\n        message: ChatMessage\n    }>\n}\n\n// Lightweight OpenAI-style client and text generation with tool support\nexport type CreateOpenAIOptions = {\n    baseURL?: string;\n    apiKey: string;\n};\n\nexport type ChatModelRef = {\n    provider: 'openai';\n    endpoint: string;\n    model: string;\n    apiKey: string;\n};\n\nexport type OpenAIClient = ((modelName: string) => ChatModelRef) & {\n    baseURL: string;\n    apiKey: string;\n    chat: (modelName: string) => ChatModelRef;\n};\n\nexport function createOpenAI(options: CreateOpenAIOptions): OpenAIClient {\n    const base = (options.baseURL ?? 'https://api-inference.modelscope.cn/v1').replace(/\\/$/, '');\n    const apiKey = options.apiKey;\n    if (!apiKey) {\n        throw new Error('apiKey is required');\n    }\n    const builder = ((modelName: string): ChatModelRef => ({\n        provider: 'openai',\n        endpoint: `${base}/chat/completions`,\n        model: modelName,\n        apiKey,\n    })) as OpenAIClient;\n    builder.baseURL = base;\n    builder.apiKey = apiKey;\n    builder.chat = (modelName: string) => builder(modelName);\n    return builder;\n}\n\nexport type GenerateTextOptions =\n    | {\n          model: ChatModelRef; // legacy: pass pre-bound model ref\n          messages: ChatMessage[];\n          tools?: Array<Tool<z.ZodTypeAny>> | Record<string, Tool<z.ZodTypeAny>>;\n          onToolCall?: (toolName: string) => void;\n      }\n    | {\n          client: OpenAIClient; // preferred: pass client and model string\n          model: string;\n          messages: ChatMessage[];\n          tools?: Array<Tool<z.ZodTypeAny>> | Record<string, Tool<z.ZodTypeAny>>;\n          onToolCall?: (toolName: string) => void;\n      };\n\nexport async function generateText(options: GenerateTextOptions): Promise<{ text: string }> {\n    const { messages, onToolCall } = options as any;\n    const messageHistory: ChatMessage[] = [...messages];\n\n    // Normalize tools to a Map for easy lookup\n    const toolMap = new Map<string, Tool<z.ZodTypeAny>>();\n    const toolsInput = (options as any).tools as Array<Tool<z.ZodTypeAny>> | Record<string, Tool<z.ZodTypeAny>> | undefined;\n    if (Array.isArray(toolsInput)) {\n        for (const t of toolsInput) toolMap.set(t.name, t as Tool<z.ZodTypeAny>);\n    } else if (toolsInput && typeof toolsInput === 'object') {\n        for (const [name, t] of Object.entries(toolsInput)) toolMap.set(name, t as Tool<z.ZodTypeAny>);\n    }\n\n    const toolsJsonSchema = toolMap.size\n        ? Array.from(toolMap.values()).map(t => ({\n              type: 'function' as const,\n              function: {\n                  name: t.name,\n                  description: t.description,\n                  parameters: zodToJsonSchema(t.parameters),\n              },\n          }))\n        : undefined;\n\n    // Normalize transport pieces\n    const baseURL = ('client' in options\n        ? (options.client as OpenAIClient).baseURL\n        : (options.model as ChatModelRef).endpoint.replace(/\\/chat\\/completions$/, '')).replace(/\\/$/, '');\n\n    const endpoint = `${baseURL}/chat/completions`;\n    const apiKey = 'client' in options ? options.client.apiKey : (options.model as ChatModelRef).apiKey;\n    const modelName = 'client' in options ? (options.model as string) : (options.model as ChatModelRef).model;\n\n    while (true) {\n        const res: ChatRespose = await fetch(endpoint, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                Authorization: `Bearer ${apiKey}`,\n            },\n            body: JSON.stringify({\n                model: modelName,\n                messages: messageHistory,\n                tools: toolsJsonSchema,\n            }),\n        }).then(r => r.json());\n\n        const assistant = res.choices?.[0]?.message;\n        if (!assistant) {\n            throw new Error('No message returned');\n        }\n\n        messageHistory.push(assistant);\n\n        const tool_calls = assistant.tool_calls;\n        if (!tool_calls || tool_calls.length === 0) {\n            return { text: assistant.content };\n        }\n\n        if (onToolCall) {\n            const toolNames = tool_calls.map(c => c.function.name);\n            toolNames.forEach(name => onToolCall(name));\n        }\n\n        // Execute tools in sequence (can be parallelized if needed)\n        for (const call of tool_calls) {\n            const tool = toolMap.get(call.function.name);\n            if (!tool) {\n                throw new Error(`Tool ${call.function.name} not found`);\n            }\n\n            const args = tool.parameters.parse(JSON.parse(call.function.arguments));\n            const result = await tool.execute(args);\n\n            messageHistory.push({\n                role: 'tool',\n                content: result,\n                tool_call_id: call.id,\n            });\n        }\n        // Loop will continue, sending the tool outputs back to the model\n    }\n}\n"],"mappings":"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","names":["index_exports","__export","createOpenAI","createTool","index_default","detectEnvironment","generateText","hello","__toCommonJS","import_zod_to_json_schema","createTool","options","wrappedExecute","args","createOpenAI","base","apiKey","builder","modelName","generateText","messages","onToolCall","messageHistory","toolMap","toolsInput","t","name","toolsJsonSchema","endpoint","assistant","r","tool_calls","c","call","tool","result","detectEnvironment","hello","name","index_default"]}